# **AIアシスタントのためのUI/UX刷新＆リファクタリング計画書 (超詳細版)**

## **1\. 本書の目的とAIへの指示原則**

### **1.1. 目的**

本計画の最終目標は、現在のアプリケーションを\*\*「Googleのようにシンプルで直感的なUI」\*\*を持つ、モダンで使いやすいサービスへと刷新することです。その実現のために、UIデザインの変更を最優先事項とし、それを支えるためのバックエンドのリファクタリングを並行して進めます。

### **1.2. AIアシスタントへの指示原則**

最高の結果を得るために、以下の原則を守ってください。

1. **コンテキストの提供:** 各タスクのプロンプトを実行する前に、対象となるファイルをAIアシスタントに読み込ませてください。  
2. **タスクの分割:** 各プロンプトは、一つの明確な責務を持つように設計されています。一度に複数のプロンプトを混ぜて実行しないでください。  
3. **検証と反復:** AIが生成したコードをレビューし、意図と異なる場合は、「その実装では〇〇という問題があります。代わりに△△というアプローチで修正してください」と対話的に修正を指示してください。

## **2\. デザイン仕様**

AIアシスタントは、以下のデザイン仕様に沿ってUIコンポーネントを生成・スタイリングしてください。

### **2.1. レイアウトモックアップ (Layout Mockup)**

このモックアップは、UIコンポーネントの配置と全体構造の**絶対的な指針**です。

 KNOWLEDGE+ (ヘッダー)  
┌──────────────────────────────────────────────────────────────────────────────┐  
|                                                                              |  
|   \[ 🔍 キーワードで検索、またはAIへの質問を入力... \] (検索ボックス)            |  
|                                                                              |  
|   \[ 検索 \] (ボタン)                                                          |  
|                                                                              |  
└──────────────────────────────────────────────────────────────────────────────┘

\--- (検索実行後にこのエリアが表示される) \-------------------------------------------

\[ タブA: AIによる要約 \] \[ タブB: 関連ナレッジ一覧 \]

▼ タブB: 関連ナレッジ一覧 の内容  
\--------------------------------------------------------------------------------  
┌───────────────────────────────────┐  
| 📄 ファイル名.pdf (カードヘッダー) |  
|                                   |  
|  ファイルから抽出されたテキストの |  
|  一部がここに表示されます...      |  
|  (カードボディ)                   |  
└───────────────────────────────────┘

### **2.2. スタイリングガイド**

* **配色:**  
  * 背景: \#FFFFFF  
  * テキスト: \#3C4043  
  * アクセントカラー: \#1a73e8 (ボタン、リンク)  
  * ボーダー: \#dfe1e5  
* **タイポグラフィ:** sans-serif系フォント。情報の階層をst.title, st.header等で明確化。  
* **状態遷移:** st.session\_stateにsearch\_executed (boolean) を持たせ、検索結果エリアの表示・非表示を制御する。

## **3\. 実行計画**

### **フェーズ 0: 開発基盤の確立 (変更なし)**

**目的:** コードの品質を自動的に維持する仕組みを整える。

* **タスク 0-1: 静的解析ツールの導入**  
* **タスク 0-2: エディタ設定の統一**

### **フェーズ 1: バックエンドの部品化 (UI刷新の準備)**

**目的:** UIから呼び出しやすいように、複雑な裏側の処理を整理・部品化する。

#### **タスク 1-1: ファイル処理ロジックの部品化**

▶ AIへのプロンプト:  
(対象: mm\_kb\_builder/app.py)  
ファイル種別ごとの処理ロジックをカプセル化します。

\*\*指示:\*\*  
1\. \`shared/file\_processor.py\` という新しいファイルを作成してください。  
2\. このファイルに、\`FileProcessor\`というクラスを作成します。  
3\. \`mm\_kb\_builder/app.py\` 内の以下の関数を、\`FileProcessor\`クラスの\*\*プライベートな静的メソッド\*\*（\`\_\`で始まる）として移動してください。  
   \- \`\_read\_pdf\`  
   \- \`\_read\_docx\`  
   \- \`\_read\_text\`  
   \- \`\_read\_image\`  
   \- \`\_read\_cad\`  
4\. \`FileProcessor\`クラスに、\`process\_file(cls, file\_path)\`という\*\*公開クラスメソッド\*\*（\`@classmethod\`）を一つだけ作成してください。このメソッドは、引数のファイルパスの拡張子を判定し、適切なプライベートメソッドを呼び出してテキストを抽出するディスパッチャとして機能します。

#### **タスク 1-2: ナレッジ構築プロセスの部品化**

▶ AIへのプロンプト:  
(対象: mm\_kb\_builder/app.py)  
ナレッジベース構築の一連の流れを、一つのクラスにまとめます。

\*\*指示:\*\*  
1\. \`shared/kb\_builder.py\` という新しいファイルを作成してください。  
2\. このファイルに \`KnowledgeBuilder\` というクラスを作成します。  
3\. \`mm\_kb\_builder/app.py\` のメインロジック（チャンク化、メタデータ生成、ベクトル化、JSONファイルへの保存処理）を、\`KnowledgeBuilder\`クラスの \`build\_from\_file(self, uploaded\_file)\` というメソッド内に移動・整理してください。  
4\. \`KnowledgeBuilder\`のコンストラクタ(\`\_\_init\_\_\`)は、\`FileProcessor\`のインスタンスを受け取り、内部で利用するように設計してください。これにより、依存関係が明確になります。

#### **タスク 1-3: 検索＆対話エンジンの部品化**

▶ AIへのプロンプト:  
(対象: knowledge\_gpt\_app/ 内の各ファイル)  
既存の検索・対話クラスを、より汎用的な部品として\`shared\`ディレクトリにまとめ、整理します。

\*\*指示:\*\*  
1\. \`knowledge\_gpt\_app/knowledge\_search.py\` を \`shared/search\_engine.py\` に移動し、クラス名を \`KnowledgeSearch\` から \`HybridSearchEngine\` に変更してください。  
2\. \`knowledge\_gpt\_app/vector\_store.py\` を \`shared/vector\_store.py\` に移動してください。  
3\. \`knowledge\_gpt\_app/gpt\_handler.py\` を \`shared/chat\_controller.py\` に移動し、クラス名を \`GptHandler\` から \`ChatController\` に変更してください。  
4\. \`ChatController\`のコンストラクタ(\`\_\_init\_\_\`)が、\`HybridSearchEngine\`のインスタンスを受け取るように依存関係を注入するコードを追加してください。  
5\. \`ChatController\`に \`generate\_response\_with\_rag(self, query)\` というメソッドを作成してください。このメソッドは、内部で\`HybridSearchEngine\`を呼び出して検索結果を取得し、それをコンテキストとしてプロンプトを構築してからOpenAI APIを呼び出すロジックを実装します。

### **フェーズ 2: UI/UXの全面刷新**

**目的:** フェーズ1で作成した部品とデザイン仕様に基づき、全く新しい「検索中心」のUIを構築する。

#### **タスク 2-1: 新UIのグローバルスタイル適用**

▶ AIへのプロンプト:  
(対象: unified\_app.py)  
新しいUIの骨格を作成し、デザイン仕様で定義したグローバルスタイルを適用します。

\*\*指示:\*\*  
1\. \`unified\_app.py\`の内容をすべて削除し、\`st.set\_page\_config(layout="wide", page\_title="KNOWLEDGE+")\` を記述してください。  
2\. \`st.markdown\`と\`\<style\>\`タグを使い、以下のカスタムCSSをページに注入してください。  
   \`\`\`css  
   /\* Main container styling \*/  
   .main .block-container {  
       max-width: 850px;  
       padding-top: 2rem;  
       padding-bottom: 2rem;  
       padding-left: 1rem;  
       padding-right: 1rem;  
   }  
   /\* General font and color \*/  
   html, body, \[class\*="st-"\] {  
       background-color: \#FFFFFF;  
       color: \#3C4043;  
   }

3. st.title("KNOWLEDGE+") でアプリのタイトルを表示してください。

\#\#\#\# \*\*タスク 2-2: 検索コンポーネントのデザイン\*\*

\*\*▶ AIへのプロンプト:\*\*  
(対象: \`unified\_app.py\`)

デザイン仕様のモックアップに基づき、検索ボックスとボタンをデザインします。

**指示:**

1. st.text\_inputを配置し、labelを"main\_search\_box"（非表示にするため）、placeholderを「キーワードで検索、またはAIへの質問を入力...」に設定してください。  
2. st.buttonで「検索」ボタンを配置してください。  
3. 以下のCSSをst.markdownで適用し、検索コンポーネントの見た目を整えてください。  
   /\* Search input styling \*/  
   \[data-testid="stTextInput"\] input {  
       border-color: \#dfe1e5;  
       border-radius: 24px;  
       padding: 10px 20px;  
   }  
   \[data-testid="stTextInput"\] input:focus {  
       border-color: \#1a73e8;  
       box-shadow: 0 0 0 1px \#1a73e8;  
   }  
   /\* Button styling \*/  
   \[data-testid="stButton"\] button {  
       background-color: \#1a73e8;  
       color: \#FFFFFF;  
       border-radius: 4px;  
       border: none;  
   }

#### **タスク 2-3: 検索結果表示エリアのデザインと画面遷移**

▶ AIへのプロンプト:  
(対象: unified\_app.py)  
検索後の画面状態と、そのデザインを実装します。

\*\*指示:\*\*  
1\. \`st.session\_state\`に\`search\_executed\`というキーを\`False\`で初期化してください。検索ボタンが押されたら\`True\`に設定します。  
2\. \`if st.session\_state.search\_executed:\`のブロック内で、\`st.tabs\`を使い、「AIによる要約」と「関連ナレッジ一覧」の2つのタブを作成してください。  
3\. 「関連ナレッジ一覧」タブには、モックアップで示した「カード形式」で各ドキュメントを表示します。以下のCSSを適用したカードを\`st.markdown\`で生成する関数 \`def render\_document\_card(doc):\` を作成し、検索結果をループして呼び出してください。  
   \`\`\`css  
   /\* Card styling \*/  
   .doc-card {  
       border: 1px solid \#dfe1e5;  
       border-radius: 8px;  
       padding: 16px;  
       margin-bottom: 16px;  
       box-shadow: 0 1px 2px 0 rgba(60,64,67,.3);  
   }

#### **タスク 2-4: ファイルアップロードエリアのデザイン**

▶ AIへのプロンプト:  
(対象: unified\_app.py)  
デザインを邪魔しない、控えめなファイルアップロードエリアを実装します。

\*\*指示:\*\*  
1\. ページのメインコンテンツの下部に、\`st.divider()\`で区切り線を入れてください。  
2\. \`st.expander\`を使い、「ナレッジを追加する」というタイトルで折りたたみ可能なエリアを作成してください。  
3\. この\`expander\`の中に\`st.file\_uploader\`を配置してください。  
4\. ファイル処理中は、\`st.spinner\`に「ファイルを解析中...」「ベクトル化しています...」のように、実行中のタスクを具体的に表示してください。処理が完了したら\`st.toast\`で通知します。

### **フェーズ 3: 品質向上とドキュメント整備**

**目的:** 新しいUIとロジックの品質をテストで担保する。

#### **タスク 3-1: テストコードの作成**

▶ AIへのプロンプト:  
(対象: tests/ ディレクトリ)  
バックエンドロジックの品質を保証するため、ユニットテストを作成します。

\*\*指示:\*\*  
1\. \`tests/test\_kb\_builder.py\`を作成してください。\`KnowledgeBuilder\`クラスの\`build\_from\_file\`メソッドをテストします。\`pytest\`の\`tmp\_path\` fixtureを使い、テスト用のPDFファイルとテキストファイルを動的に作成し、処理後に期待されるJSONファイル（チャンク、メタデータ、エンベディング）が3つ生成されることを\`assert\`で検証してください。  
2\. \`tests/test\_search\_engine.py\`を作成してください。\`HybridSearchEngine\`のテストを行います。モックデータ（ダミーのベクトルストアと検索結果）を使い、\`hybrid\_search\`メソッドが期待通りの形式で結果を返すことを検証してください。

#### **タスク 3-2: ドキュメントの更新**

▶ AIへのプロンプト:  
(対象: README.md)  
プロジェクトのドキュメントを、新しいUIとアーキテクチャに合わせて更新します。

\*\*指示:\*\*  
1\. \`README.md\`を全面的に書き換えてください。  
2\. 「アーキテクチャ」セクションを新設し、\`FileProcessor\`, \`KnowledgeBuilder\`, \`HybridSearchEngine\`, \`ChatController\`, \`unified\_app.py\`の5つの主要コンポーネントがどのように連携するかを説明する図を、Mermaid.jsのグラフ構文を使って記述してください。  
